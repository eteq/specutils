
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>specutils.spectra.spectrum_mixin &#8212; specutils v0.4.dev1227</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">spec</span><span id="logotext2">utils</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">specutils v0.4.dev1227</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for specutils.spectra.spectrum_mixin</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="k">import</span> <span class="n">WCSSUB_SPECTRAL</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="k">import</span> <span class="n">Unit</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="k">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">import</span> <span class="nn">astropy.units.equivalencies</span> <span class="k">as</span> <span class="nn">eq</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="k">import</span> <span class="n">lazyproperty</span>

<span class="n">DOPPLER_CONVENTIONS</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">DOPPLER_CONVENTIONS</span><span class="p">[</span><span class="s1">&#39;radio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">doppler_radio</span>
<span class="n">DOPPLER_CONVENTIONS</span><span class="p">[</span><span class="s1">&#39;optical&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">doppler_optical</span>
<span class="n">DOPPLER_CONVENTIONS</span><span class="p">[</span><span class="s1">&#39;relativistic&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">doppler_relativistic</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;OneDSpectrumMixin&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="OneDSpectrumMixin"><a class="viewcode-back" href="../../../api/specutils.spectra.spectrum_mixin.OneDSpectrumMixin.html#specutils.spectra.spectrum_mixin.OneDSpectrumMixin">[docs]</a><span class="k">class</span> <span class="nc">OneDSpectrumMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_spectral_axis_numpy_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_spectral_axis_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        How many elements are in the spectral dimension?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_spectral_axis_numpy_index</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_data_with_spectral_axis_last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a view of the data with the spectral axis last</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectral_axis_numpy_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spectral_axis_numpy_index</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_data_with_spectral_axis_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a view of the data with the spectral axis first</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectral_axis_numpy_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spectral_axis_numpy_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral_wcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">spectral</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">spectral_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Quantity array with the values of the spectral axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">pixel_to_world</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral_axis_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the units of the spectral axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">spectral_axis_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the stored data and unit information into a quantity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.units.Quantity`</span>
<span class="sd">            Spectral data as a quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="OneDSpectrumMixin.new_flux_unit"><a class="viewcode-back" href="../../../api/specutils.spectra.spectrum_mixin.OneDSpectrumMixin.html#specutils.spectra.spectrum_mixin.OneDSpectrumMixin.new_flux_unit">[docs]</a>    <span class="k">def</span> <span class="nf">new_flux_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_conversion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the flux data to the specified unit.  This is an in-place</span>
<span class="sd">        change to the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : str or `~astropy.units.Unit`</span>
<span class="sd">            The unit to conver the flux array to.</span>

<span class="sd">        equivalencies : list of equivalencies</span>
<span class="sd">            Custom equivalencies to apply to conversions.</span>
<span class="sd">            Set to spectral_density by default.</span>

<span class="sd">        suppress_conversion : bool</span>
<span class="sd">            Set to true if updating the unit without</span>
<span class="sd">            converting data values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~specutils.Spectrum1D`</span>
<span class="sd">            A new spectrum with the converted flux array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_spec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_conversion</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">equivalencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">)</span>

            <span class="n">new_spec</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">value</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_spec</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity_convention</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_velocity_convention</span>

<div class="viewcode-block" id="OneDSpectrumMixin.with_velocity_convention"><a class="viewcode-back" href="../../../api/specutils.spectra.spectrum_mixin.OneDSpectrumMixin.html#specutils.spectra.spectrum_mixin.OneDSpectrumMixin.with_velocity_convention">[docs]</a>    <span class="k">def</span> <span class="nf">with_velocity_convention</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">velocity_convention</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
                              <span class="n">velocity_convention</span><span class="o">=</span><span class="n">velocity_convention</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rest_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rest_value</span>

    <span class="nd">@rest_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">rest_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">spectral</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span>
                <span class="s2">&quot;Rest value must be energy/wavelength/frequency equivalent.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rest_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the spectral axis array to the given velocity space unit given</span>
<span class="sd">        the rest value.</span>

<span class="sd">        These aren&#39;t input parameters but required Spectrum attributes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : str or ~`astropy.units.Unit`</span>
<span class="sd">            The unit to convert the dispersion array to.</span>
<span class="sd">        rest : ~`astropy.units.Quantity`</span>
<span class="sd">            Any quantity supported by the standard spectral equivalencies</span>
<span class="sd">            (wavelength, energy, frequency, wave number).</span>
<span class="sd">        type : {&quot;doppler_relativistic&quot;, &quot;doppler_optical&quot;, &quot;doppler_radio&quot;}</span>
<span class="sd">            The type of doppler spectral equivalency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~`astropy.units.Quantity`</span>
<span class="sd">            The converted dispersion array in the new dispersion space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_rest_value&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rest_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot get velocity representation of spectral &quot;</span>
                             <span class="s2">&quot;axis without specifying a reference value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_velocity_convention&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_velocity_convention</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot get velocity representation of spectral &quot;</span>
                             <span class="s2">&quot;axis without specifying a velocity convention.&quot;</span><span class="p">)</span>

        <span class="n">equiv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">,</span> <span class="s1">&#39;doppler_</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_convention</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_value</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">km</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equiv</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_data</span>

<div class="viewcode-block" id="OneDSpectrumMixin.with_spectral_unit"><a class="viewcode-back" href="../../../api/specutils.spectra.spectrum_mixin.OneDSpectrumMixin.html#specutils.spectra.spectrum_mixin.OneDSpectrumMixin.with_spectral_unit">[docs]</a>    <span class="k">def</span> <span class="nf">with_spectral_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">velocity_convention</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">rest_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new spectrum with a different spectral axis unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : :class:`~astropy.units.Unit`</span>
<span class="sd">            Any valid spectral unit: velocity, (wave)length, or frequency.</span>
<span class="sd">            Only vacuum units are supported.</span>
<span class="sd">        velocity_convention : &#39;relativistic&#39;, &#39;radio&#39;, or &#39;optical&#39;</span>
<span class="sd">            The velocity convention to use for the output velocity axis.</span>
<span class="sd">            Required if the output type is velocity. This can be either one</span>
<span class="sd">            of the above strings, or an `astropy.units` equivalency.</span>
<span class="sd">        rest_value : :class:`~astropy.units.Quantity`</span>
<span class="sd">            A rest wavelength or frequency with appropriate units.  Required if</span>
<span class="sd">            output type is velocity.  The spectrum&#39;s WCS should include this</span>
<span class="sd">            already if the *input* type is velocity, but the WCS&#39;s rest</span>
<span class="sd">            wavelength/frequency can be overridden with this parameter.</span>

<span class="sd">            .. note: This must be the rest frequency/wavelength *in vacuum*,</span>
<span class="sd">                     even if your spectrum has air wavelength units</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_wcs</span><span class="p">,</span> <span class="n">new_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_spectral_wcs</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">velocity_convention</span><span class="o">=</span><span class="n">velocity_convention</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_velocity_convention</span><span class="p">,</span>
            <span class="n">rest_value</span><span class="o">=</span><span class="n">rest_value</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_value</span><span class="p">)</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">new_wcs</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">new_meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spectrum</span></div>

    <span class="k">def</span> <span class="nf">_new_wcs_argument_validation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">velocity_convention</span><span class="p">,</span>
                                     <span class="n">rest_value</span><span class="p">):</span>
        <span class="c1"># Allow string specification of units, for example</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitBase</span><span class="p">):</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># Velocity conventions: required for frq &lt;-&gt; velo</span>
        <span class="c1"># convert_spectral_axis will handle the case of no velocity</span>
        <span class="c1"># convention specified &amp; one is required</span>
        <span class="k">if</span> <span class="n">velocity_convention</span> <span class="ow">in</span> <span class="n">DOPPLER_CONVENTIONS</span><span class="p">:</span>
            <span class="n">velocity_convention</span> <span class="o">=</span> <span class="n">DOPPLER_CONVENTIONS</span><span class="p">[</span><span class="n">velocity_convention</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">velocity_convention</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
              <span class="n">velocity_convention</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DOPPLER_CONVENTIONS</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Velocity convention must be radio, optical, &quot;</span>
                             <span class="s2">&quot;or relativistic.&quot;</span><span class="p">)</span>

        <span class="c1"># If rest value is specified, it must be a quantity</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rest_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rest_value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span> <span class="ow">or</span>
             <span class="ow">not</span> <span class="n">rest_value</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">spectral</span><span class="p">()))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rest value must be specified as an astropy &quot;</span>
                             <span class="s2">&quot;quantity with spectral equivalence.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">_new_spectral_wcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">velocity_convention</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">rest_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new WCS with a different Spectral Axis unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : :class:`~astropy.units.Unit`</span>
<span class="sd">            Any valid spectral unit: velocity, (wave)length, or frequency.</span>
<span class="sd">            Only vacuum units are supported.</span>
<span class="sd">        velocity_convention : &#39;relativistic&#39;, &#39;radio&#39;, or &#39;optical&#39;</span>
<span class="sd">            The velocity convention to use for the output velocity axis.</span>
<span class="sd">            Required if the output type is velocity. This can be either one</span>
<span class="sd">            of the above strings, or an `astropy.units` equivalency.</span>
<span class="sd">        rest_value : :class:`~astropy.units.Quantity`</span>
<span class="sd">            A rest wavelength or frequency with appropriate units.  Required if</span>
<span class="sd">            output type is velocity.  The cube&#39;s WCS should include this</span>
<span class="sd">            already if the *input* type is velocity, but the WCS&#39;s rest</span>
<span class="sd">            wavelength/frequency can be overridden with this parameter.</span>

<span class="sd">            .. note: This must be the rest frequency/wavelength *in vacuum*,</span>
<span class="sd">                     even if your cube has air wavelength units</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_wcs_argument_validation</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">velocity_convention</span><span class="p">,</span>
                                                 <span class="n">rest_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">velocity_convention</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">equiv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s1">&#39;doppler_</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">velocity_convention</span><span class="p">))</span>
            <span class="n">rest_value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equiv</span><span class="p">)</span>

        <span class="c1"># Store the original unit information for posterity</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;original_unit&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;original_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">spectral_axis_unit</span>

        <span class="c1"># Create the new wcs object</span>
        <span class="n">new_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">with_spectral_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
                                         <span class="n">rest_value</span><span class="o">=</span><span class="n">rest_value</span><span class="p">,</span>
                                         <span class="n">velocity_convention</span><span class="o">=</span><span class="n">velocity_convention</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_wcs</span><span class="p">,</span> <span class="n">meta</span></div>


<span class="k">class</span> <span class="nc">InplaceModificationMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Example methods follow to demonstrate how methods can be written to be</span>
    <span class="c1"># agnostic of the non-spectral dimensions.</span>

    <span class="k">def</span> <span class="nf">substract_background</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">background</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Proof of concept, this subtracts a background spectrum-wise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_with_spectral_axis_last</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">background</span><span class="p">):</span>
            <span class="c1"># create substractable array</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">background</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">substractable_continuum</span> <span class="o">=</span> <span class="n">background</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;background needs to be callable or have the same shape as the spectum&quot;</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">substractable_continuum</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Proof of concept, this normalizes each spectral dimension based</span>
<span class="sd">        on a trapezoidal integration.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this gets a view - if we want normalize to return a new NDData object</span>
        <span class="c1"># then we should make _data_with_spectral_axis_first return a copy.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_with_spectral_axis_first</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">/=</span> <span class="n">norm</span>

    <span class="k">def</span> <span class="nf">spectral_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectral_value</span><span class="p">,</span> <span class="n">flux_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Proof of concept, this interpolates along the spectral dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_with_spectral_axis_last</span>

        <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>

        <span class="n">interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">spectral_value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                              <span class="n">equivalencies</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>

        <span class="k">if</span> <span class="n">flux_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Lim: Is this acceptable?</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">flux_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2018, Nicholas Earl.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.5. &nbsp;
    Last built 19 Sep 2018. <br/>
  </p>
</footer>
  </body>
</html>